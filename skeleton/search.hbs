<script type="text/javascript" src="/assets/js/handlebars.runtime.min.js"></script>
<script type="text/javascript" src="/assets/js/didyoumean.js"></script>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
    {{{handlebarsHelpers}}}
    var tpl = Handlebars.template({{{precompiledSearchResultsTemplate}}});
    var $search = document.getElementById('search');

    if ($search !== null) { new Search(tpl, $search).search(); }

    function Search(tpl, $search) {
        function search() {
            new Promise(function(resolve) {
                // get literal query string
                var q = _getQ();

                if (q !== '') {
                    _setSearchInputs(q);

                    // load search index with AJAX
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', '/search.json');

                    xhr.onreadystatechange = function() {
                        // DONE
                        if (xhr.readyState === 4) {
                            // OK
                            if (xhr.status === 200) {
                                // parse search index
                                var index = _parseIndex(xhr);

                                if (index !== null) {
                                    // parse query string
                                    // test with:
                                    // foo "bar" +baz +"qux" -waldo -"thud" + corge" - +"grault -"xyzzy +1234 -1234
                                    var parsedQ = _parseQ(q);

                                    // get result for all terms
                                    var results = _getResults(parsedQ, index);

                                    resolve({ results: results, q: q });
                                } else { resolve({ results: [], q: q }); }
                            } else { resolve({ results: [], q: q }); }
                        }
                    };

                    xhr.send(null);
                } else { resolve({ results: [], q: q }); }
            }).then(function(results) {
                // show results with precompiled Handlebars template
                $search.innerHTML = tpl(results);
            });
        }

        function _getQ() {
            // check whether search term is in the URL
            return typeof URLSearchParams !== 'undefined'
                ? new URLSearchParams(location.search.slice(1)).get('q').trim().toLowerCase()
                : ''
            ;
        }

        function _getQueryString(terms) {
            return typeof URLSearchParams !== 'undefined'
                ? '?' + new URLSearchParams({ m: JSON.stringify(terms) }).toString()
                : ''
            ;
        }

        function _getResults(parsedQ, index) {
            var terms = Object.keys(index.t);

            var hits = Object.keys(parsedQ).reduce(function(hits, key) {
                var tmp = {};

                // we store the original term in the shorthand ot, because the fuzzy search results might contain
                // a different term, because "bass" also fuzzy matches "bash".
                tmp[key] = parsedQ[key].reduce(function(hits2, data) {
                    var hits3 = (
                        data.fuzzy === true
                            // the fuzzy matching lacks matching whether the term literally exists somewhere in
                            // the terms. this is why both methods get mixed up here and then the result array
                            // has to be uniqued.
                            ? didYouMean.default(data.term, terms, {
                                returnType: didYouMean.ReturnTypeEnums.ALL_CLOSEST_MATCHES
                            }).concat(
                                terms.filter(function(term) { return term.indexOf(data.term) !== -1; })
                            ).filter(function(term, i, arr) { return arr.indexOf(term) === i; })
                            : terms.filter(function(term) { return term.indexOf(data.term) !== -1; })
                    ).map(function(term) { return Object.assign({}, index.t[term], { ot: data.term, t: term }); });

                    return hits2.concat(hits3.length > 0 ? hits3 : { b: {}, c: 0, ot: data.term, p: {}, t: data.term });
                }, []);

                return Object.assign({}, hits, tmp);
            }, {});

            // AND is a quite hard thing, because if one AND condition is not met, the whole result is empty.
            // this is why we test for this here first to safe us time and energy.
            if (hits.and.some(function(hit) { return hit.c === 0; })) { return []; }

            var cummulated = ['and', 'not', 'or'].reduce(function(result, key) {
                var tmp = {};

                tmp[key] = ['b', 'p'].reduce(function(result2, key2) {
                    var tmp2 = {};

                    tmp2[key2] = hits[key].reduce(function(result3, values) {
                        return Object.assign({}, result3, Object.keys(values[key2]).reduce(function(result4, key3) {
                            var tmp3 = {};
                            var terms = {};
                            terms[values.t] = values[key2][key3];

                            tmp3[key3] = (
                                key3 in result3
                                    ? Object.assign(
                                        {}
                                        , result3[key3]
                                        , {
                                            count: result3[key3].count + values[key2][key3]
                                            , originalTerms: result3[key3].originalTerms.concat(
                                                result3[key3].originalTerms.indexOf(values.ot) === -1 ? values.ot : []
                                            )
                                            , terms: Object.assign({}, result3[key3].terms, terms)
                                        }
                                    )
                                    : Object.assign(
                                        {}
                                        , index[key2][key3]
                                        , {
                                            count: values[key2][key3]
                                            , originalTerms: [values.ot]
                                            , terms: terms
                                        }
                                    )
                            );

                            return Object.assign({}, result4, tmp3);
                        }, {}));
                    }, {});

                    return Object.assign({}, result2, tmp2);
                }, {});

                return Object.assign({}, result, tmp);
            }, {});

            var andQLength = parsedQ.and.map(function(value) { return value.term; }).length;
            var filtered = ['b', 'p'].reduce(function(result, key) {
                var tmp = {};
                var andKeys = Object.keys(cummulated.and[key]);
                var notKeys = Object.keys(cummulated.not[key]);

                tmp[key] = Object.keys(cummulated.or[key]).reduce(function(result2, key2) {
                    if (
                        (
                            andKeys.length === 0
                            || (
                                andKeys.indexOf(key2) !== -1
                                && cummulated.and[key][key2].originalTerms.length === andQLength
                            )
                        )
                        && (notKeys.length === 0 || notKeys.indexOf(key2) === -1)
                    ) {
                        var tmp2 = {};

                        tmp2[key2] = andKeys.length > 0 ? Object.assign(
                            {}
                            , cummulated.or[key][key2]
                            , {
                                count: cummulated.or[key][key2].count + cummulated.and[key][key2].count
                                , originalTerms: cummulated.or[key][key2].originalTerms.concat(
                                    cummulated.and[key][key2].originalTerms
                                )
                                , terms: Object.assign(
                                    {}
                                    , cummulated.or[key][key2].terms
                                    , cummulated.and[key][key2].terms
                                )
                            }
                        ) : cummulated.or[key][key2];

                        return Object.assign({}, result2, tmp2);
                    }

                    return result2;
                }, {});

                return Object.assign({}, result, tmp);
            }, {});

            var mixedSorted = ['b', 'p'].reduce(function(result, key) {
                return result.concat(Object.keys(filtered[key]).map(function(key2) {
                    return Object.assign({}, filtered[key][key2], {
                        queryString: _getQueryString(Object.keys(filtered[key][key2].terms))
                        , type: key === 'b' ? 'blogEntry' : 'page'
                    });
                }));
            }, []).sort(function(a, b) {
                if (b.count < a.count) { return -1; }
                if (b.count > a.count) { return 1; }
                if (a.type === 'blogEntry' && b.type === 'page') { return -1; }
                if (a.type === 'page' && b.type === 'blogEntry') { return 1; }
                return 0;
            });

            return mixedSorted;
        }

        function _parseIndex(xhr) {
            var index = null;

            try { index = JSON.parse(xhr.responseText); } catch(ex) {}

            return index;
        }

        function _parseQ(q) {
            var already = {};

            return q.split(/\s+/g).reduce(function(parsedQ, term) {
                var key = 'or';
                var fuzzy = true;
                var tmp = {};

                if (term.slice(0, 1) === '+') {
                    key = 'and';
                    term = term.slice(1);
                }
                else if (term.slice(0, 1) === '-') {
                    key = 'not';
                    term = term.slice(1);
                }

                if (term.slice(0, 1) === '"' && term.slice(-1) === '"') {
                    fuzzy = false;
                    term = term.slice(1, -1);
                }

                if (!(term in already) && /^[a-z]+$/.test(term)) {
                    already[term] = true;

                    tmp[key] = parsedQ[key].concat({ fuzzy: fuzzy, term: term });

                    return Object.assign({}, parsedQ, tmp);
                }

                return parsedQ;
            }, { and: [], not: [], or: [] });
        }

        function _setSearchInputs(q) {
            // set search forms in the rest of the DOM to the query string
            var $qs = document.querySelectorAll('.search-form__q');

            if ($qs !== null) { Array.from($qs).forEach(function($q) { $q.value = q; }); }
        }

        return { search };
    }
});
</script>
<div class="search-results" id="search"></div>
